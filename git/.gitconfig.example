[user]
	signingKey = PLACEHOLDER_SIGNING_KEY
	name = PLACEHOLDER_NAME
	email = PLACEHOLDER_EMAIL
[diff]
	# tool = meld
	noprefix = true
	wsErrorHighlight = all
[diffltool]
	prompt = true
[difftool "meld"]
	trustExitCode = true
[merge]
	conflictstyle = zdiff3
[mergetool]
	prompt = true
[mergetool "meld"]
	trustExitCode = true
[core]
	pager = delta # less -F -X
	excludesfile = "~/.gitignore_global"
	attributesfile = "~/.gitattributes"
	# Warning to ensure files end with a newline
	whitespace = blank-at-eol,blank-at-eof
    eol = lf
[cola]
	spellcheck = false
	expandtab = true
[gui]
	editor = nvim
[delta]
	navigate = true
	dark = true
	true-color = always
	side-by-side = true
	line-numbers = true
[interactive]
	diffFilter = delta --color-only
[alias]
	tree = "!git log --graph --decorate --pretty=format:'%C(yellow)%h %Cred%cr %Cblue(%an)%C(cyan)%d%Creset %s' --abbrev-commit --all"
    log-my-week = !git log --author $(git config user.email) --since "1 week ago"
    # Revert last commit
    uncommit = reset --soft HEAD~1
    # Add changes to Stash and apply it back
    snapshot = !git stash push -m \"snapshot: $(date)\" && git stash apply stash@{0}
    # Delete the most recent snapshot stash with confirmation (use -f to force without confirmation)
    delsnapshot = "!f() { \
        force=false; \
        if [ \"$1\" = \"-f\" ] || [ \"$1\" = \"--force\" ]; then \
            force=true; \
        fi; \
        snapshot_entry=$(git stash list | grep 'snapshot:' | head -n1); \
        if [ -n \"$snapshot_entry\" ]; then \
            snapshot_ref=$(echo \"$snapshot_entry\" | cut -d: -f1); \
            branch=$(echo \"$snapshot_entry\" | cut -d: -f2 | sed 's/^ *//'); \
            timestamp=$(echo \"$snapshot_entry\" | grep -o 'snapshot:.*' | sed 's/snapshot: *//'); \
            echo \"ðŸ“¸ Snapshot found:\"; \
            echo \"   Branch: $branch\"; \
            echo \"   Time: $timestamp\"; \
            echo \"   Ref: $snapshot_ref\"; \
            if $force; then \
                echo \"\"; \
                git stash drop \"$snapshot_ref\"; \
                echo \"âœ… Snapshot deleted (forced)\"; \
            else \
                echo \"\"; \
                echo -n \"Delete this snapshot? (y/N): \"; \
                read confirm; \
                if [ \"$confirm\" = \"y\" ] || [ \"$confirm\" = \"Y\" ]; then \
                    git stash drop \"$snapshot_ref\"; \
                    echo \"âœ… Snapshot deleted\"; \
                else \
                    echo \"âŒ Cancelled\"; \
                    return 1; \
                fi; \
            fi; \
        else \
            echo 'âŒ No snapshot found in stash list.'; \
            return 1; \
        fi; \
    }; f"
    force-delsnapshot = delsnapshot --force

    # Sync the fork repository with the upstream
    syncfork = "!sh $DOTFILES_PATH/git/git_sync_forked_repository.sh"

    safereset = "!f() { \
        trap 'echo ERROR: Operation failed; return' ERR; \
        echo Making sure there are no changes...; \
        last_status=$(git status --porcelain);\
        if [[ $last_status != \"\" ]]; then\
            echo There are dirty files:;\
            echo \"$last_status\";\
            echo;\
            echo -n \"Enter Y if you would like to DISCARD these changes or W to commit them as WIP: \";\
            read dirty_operation;\
            if [ \"$dirty_operation\" == \"Y\" ]; then \
                echo Resetting...;\
                git reset --hard;\
            elif [ \"$dirty_operation\" == \"W\" ]; then\
                echo Comitting WIP...;\
                git commit -a --message='WIP' > /dev/null && echo WIP Comitted;\
            else\
                echo Operation cancelled;\
                exit 1;\
            fi;\
        fi;\
    }; \
    f"

    lastcommit = !git rev-list -n 1 HEAD --pretty=format:%s
    wdiff = diff --word-diff --color-words

    # Get the default branch based on remote/local target
    # Usage: git default-branch [origin|upstream|local|<remote-name>] [--strict]
    # The default is 'origin' if no argument is provided
    # Remote 'origin' is the default remote-name used when cloning a repository
    # Remote 'upstream' is commonly used for forked repositories to point to the original repository
    # The 'local' option retrieves the local default branch (init.defaultBranch) if remote HEAD is not found
    # --strict flag: Exit with error if remote doesn't exist (instead of falling back to init.defaultBranch)
    # Note: If the specified remote doesn't exist, falls back to init.defaultBranch config (unless --strict is used)
    # Examples:
    #   git default-branch                -> returns origin's default branch (e.g., 'main')
    #   git default-branch upstream       -> returns upstream's default branch or init.defaultBranch if not found
    #   git default-branch local          -> returns init.defaultBranch (e.g., 'main')
    #   git default-branch upstream --strict  -> exits with error if upstream remote doesn't exist
    # TODO: Consider this as boilerplate for sd vs sed usage based on availability
    # Consider this as boilerplate for sd vs sed usage based on availability
    # if sd is installed, use it for better performance
    # if not, fallback to sed
    # TODO: if not interested, just remove the conditional and use your choice
    default-branch = "!f() { \
        target=\"origin\"; \
        strict=false; \
        is_remote=true; \
        for arg in \"$@\"; do \
            if [ \"$arg\" = \"--strict\" ]; then \
                strict=true; \
            elif [ \"$arg\" = \"local\" ]; then \
                is_remote=false; \
                target=\"origin\"; \
            else \
                target=\"$arg\"; \
            fi; \
        done; \
        if command -v sd >/dev/null 2>&1; then \
            branch=$(git symbolic-ref refs/remotes/$target/HEAD 2>/dev/null | sd \"^refs/remotes/$target/\" ''); \
        else \
            branch=$(git symbolic-ref refs/remotes/$target/HEAD 2>/dev/null | sed \"s|^refs/remotes/$target/||\"); \
        fi; \
        if [ -n \"$branch\" ]; then \
            echo \"$branch\"; \
        elif $strict && $is_remote; then \
            echo \"Error: Remote '$target' does not exist or has no HEAD reference\" >&2; \
            return 1; \
        else \
            git config --get init.defaultBranch; \
        fi; \
    }; f"

    # Get the default branch name from the origin remote
    default-origin-branch = "!f() { git default-branch origin \"$@\"; }; f"

    # Get the default branch name from the upstream remote
    default-upstream-branch = "!f() { git default-branch upstream \"$@\"; }; f"

    # Get the local default branch (tries remote HEAD, then init.defaultBranch config)
    default-local-branch = "!f() { git default-branch local \"$@\"; }; f"

    # Sync the working branch with the default branch
    sync-working-with-default = !git fetch && git rebase origin/$(git default-origin-branch)


    # Sync the working branch with the default branch
    sync-working-with-default = !git fetch && git rebase origin/$(git default-origin-branch)

    # Add final newline to all tracked files in repository
    fix-eof-newlines-all = !git ls-files -z | xargs -0 sed -i '' -e '$a\\'

    # Add final newline to files changed in current branch (compared to default branch)
    fix-eof-newlines-branch = "!f() { \
        default_branch=$(git default-origin-branch); \
        git diff --name-only --diff-filter=ACM -z origin/$default_branch...HEAD | xargs -0 sed -i '' -e '$a\\'; \
    }; f"

[merge]
	tool = meld
[commit]
	gpgsign = true
;[gpg]
;	program = /usr/local/bin/gpg
; git config --show-origin --get user.email to test
[includeIf "gitdir/i:~/Projects/"]
	path = "~/Projects/gitconfig"
[pull]
	ff = only
[init]
	defaultBranch = main
[gpg]
	program = gpg2
[diff "sopsdiffer"]
	textconv = sops -d
[credential]
	helper =
	helper = /usr/local/share/gcm-core/git-credential-manager
[credential "https://dev.azure.com"]
	useHttpPath = true
[filter "lfs"]
	clean = git-lfs clean -- %f
	smudge = git-lfs smudge -- %f
	process = git-lfs filter-process
	required = true
